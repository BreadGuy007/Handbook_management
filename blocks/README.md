# Blocks

Block is the abstract term used to describe units of markup that, composed together, form the content or layout of a webpage. The idea combines concepts of what in WordPress today we achieve with shortcodes, custom HTML, and embed discovery into a single consistent API and user experience.

For more context, refer to [_What Are Little Blocks Made Of?_](https://make.wordpress.org/design/2017/01/25/what-are-little-blocks-made-of/) from the [Make WordPress Design](https://make.wordpress.org/design/) blog.

The following documentation outlines steps you as a developer will need to follow to add your own custom blocks to WordPress's editor interfaces.

## Getting Started

If you're not already accustomed to working with JavaScript in your WordPress plugins, you may first want to reference the guide on [_Including CSS & JavaScript_](https://developer.wordpress.org/themes/basics/including-css-javascript/) in the Theme Handbook.

At a minimum, you will need to enqueue scripts for your block as part of a `block_enqueue_scripts` action callback, with a dependency on the `wp-blocks` script handle:

```php
<?php
// plugin.php

function myplugin_block_enqueue_scripts() {
	wp_enqueue_script( 'myplugin-block', plugins_url( 'block.js', __FILE__ ), array( 'wp-blocks' ) );
}
add_action( 'block_enqueue_scripts', 'myplugin_block_enqueue_scripts' );
```

The following sections will describe what you'll need to include in `block.js` to describe the behavior of your custom block.

## Example

Let's imagine you wanted to define a block to enable you or other users on your site to insert a [Gravatar](http://en.gravatar.com/) image. The URL for a Gravatar image is determined by applying an [md5 hash](https://en.wikipedia.org/wiki/MD5) on an email address and appending it as a path to `gravatar.com/avatar/[hash]`. Of course, it's not a very interesting example if the user can't customize the block, so we'll assume it's a requirement to provide an email address of their choosing.

Take a step back and consider the ideal workflow for adding a Gravatar. After inserting a new "Gravatar" block, as a user I'd expect it to be shown in some empty state, with an option to add an email address in a [text input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Upon entering an email address, a preview of the image should be shown next to the input. At this point, you might realize that while you'd want some controls to be shown when editing content, the markup included in the published post might not appear the same (your visitors should not see an input field when reading your content). This leads to the first requirement of describing a block: __you will need to provide implementations both for what's to be shown in an editor and what's to be saved with the published content__. You needn't worry about redundant effort here, as concepts of [Elements](../elements/README.md) and componentization provide an avenue for sharing common behaviors.

Now that we've considered user interaction, you should think about the underlying values that determine the markup generated by your block. In our example, the output is affected only when the email address changes. Put another way: __the output of a block is a function of its attributes__. The email address, a simple string, is the only thing we require to be able to generate the image we want to include in the published content. We call these underlying values of a block instance its _attributes_.

With these concepts in mind, let's explore an implementation of our Gravatar block:

```php
<?php
// plugin.php

function gravatar_block_enqueue_scripts() {
	wp_register_script( 'blueimp-md5', 'https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.7.0/js/md5.min.js' );
	wp_enqueue_script( 'gravatar-block', plugins_url( 'block.js', __FILE__ ), array( 'wp-blocks', 'wp-element', 'blueimp-md5' ) );
}
add_action( 'block_enqueue_scripts', 'gravatar_block_enqueue_scripts' );
```

```js
// block.js

var el = wp.element.createElement;

function GravatarImage( props ) {
	var src = 'https://gravatar.com/avatar/' + md5( props.email );

	return el( 'img', { src: props.src } );
}

wp.blocks.registerBlock( 'myplugin/gravatar', {
	edit: function( block ) {
		var email = block.attributes.email,
			children;

		function onSubmit( event ) {
			var input = event.target.querySelector( 'input' );
			block.setAttributes( { email: input.value } );
			event.preventDefault();
		}

		function onBlur( event ) {
			block.setAttributes( { email: event.target.value } );
		}

		children = el( 'input', { value: email, onBlur: onBlur } );
		if ( email ) {
			children.unshift( GravatarImage( { email: email } ) );
		}

		return el( 'form', { onSubmit: setEmail }, children );
	},
	save: function( block ) {
		return GravatarImage( { email: block.attributes.email } );
	}
} );
```

_[(Example in ES2015+, JSX)](https://gist.github.com/aduth/fb1cc9a2296110a62b96383e4b2e8a7c)_

Let's briefly review a few items you might observe in the implementation:

- There's no built-in JavaScript MD5 hash function, so we pull in [a common implementation](https://github.com/blueimp/JavaScript-MD5).
- When registering a new block, you must prefix its slug with a namespace for your plugin. This helps prevent conflicts when more than one plugin registers a block with the same slug.
- You will use `createElement` to describe the structure of your block's markup. See the [Element documentation](../element/README.md) for more information.
- Extracting `GravatarImage` to a separate function allows us to reuse it in both the editor-specific interface and the published content.
- The `edit` function should handle any case where an attribute is unset, as in the case of the block being newly inserted, or reset to its original values
- We only change the attributes of a block by calling the `setAttributes` helper. Never assign a value on the attributes object directly.

There's a few small details that aren't obvious though:

- How are a block's attributes stored when saving a post, so that they're restored next time I edit the same post?
- Keen to avoid spam, how can I ensure I'm not including the email address in the published content?

The single answer to both of these questions is that the combined state of every block in a post is saved as [post meta](https://codex.wordpress.org/Custom_Fields#Advanced_Techniques_for_Custom_Fields). This ensures that the attributes of a block are preserved and kept separate from the markup between editing sessions. 

## API

### `wp.blocks.registerBlock( slug: string, settings: Object )`

Registers a new block provided a unique slug and an object defining its behavior. Once registered, the block is made available as an option to any editor interface where blocks are implemented.

- `name: string` - A human-readable [localized](https://codex.wordpress.org/I18n_for_WordPress_Developers#Handling_JavaScript_files) label for the block. Shown in the block picker.
- `edit( { attributes: Object, setAttributes: Function } ): WPElement` - Returns an element describing the markup of a block to be shown in the editor. A block can update its own state in response to events using the `setAttributes` function, passing an object of properties to be applied as a partial update.
- `save( { attributes: Object } ): WPElement` - Returns an element describing the markup of a block to be saved in the published content. This function is called before save and when switching to an editor's HTML view.
- `tagName: string` - An alternative to defining `edit` and `save` behaviors, if passed a [tag name](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement#Parameters), delegates default behavior of an editable field on that node type. Typically used for simple, text-heavy elements (paragraphs, headings) to avoid excess meta storage of text.
- `controls: string[]` - Slugs for controls to be made available to block. See also: [`wp.blocks.registerControl`](#wpblocksregistercontrol-slug-string-settings-object-)

### `wp.blocks.registerControl( slug: string, settings: Object )`

Registers a new block-level control. Controls appear in a block's toolbar when it receives focus if it is included in the block's `controls` option.

- `icon: string | WPElement` - Slug of the [Dashicon](https://developer.wordpress.org/resource/dashicons/#awards) to be shown in the control's button, or an element if you choose to render your own SVG.
- `onClick( { attributes: Object, setAttributes: Function } )` - Click behavior for control. Use this to change or toggle an attribute of the block.
- `isVisible( { attributes: Object } ): boolean` - Called when a block receives focus or changes. Return `false` to prevent the control's button from being shown. If this option is not defined for a control, the button will always be shown.
- `isActive( { attributes: Object } ): boolean` - Called when a block receives focus or changes. Return `true` to apply an active effect to the control's button, in the case that the control's behavior is a toggle. 

Inline controls for [`Editable`](#editable) elements are identical for every block and cannot be modified.

### `wp.blocks.getBlockSettings( slug: string )`

Returns settings associated with a registered block.

### `wp.blocks.getControlSettings( slug: string )`

Returns settings associated with a registered control.

## Components

Because many blocks share the same complex behaviors, the following components are made available to simplify implementations of your block's `edit` function.

### `Editable`

Render a rich [`contenteditable` input](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Editable_content), providing users the option to add emphasis to content or links to content. It behaves similar to a [controlled component](https://facebook.github.io/react/docs/forms.html#controlled-components), except that `onChange` is triggered less frequently than would be expected from a traditional `input` field, usually when the user exits the field.

The following props are made available:

- `inline: boolean` - If true, only inline elements are allowed to be used in inserted into the text, effectively disabling the behavior of the "Enter" key.
- `value: string` - Markup value of the editable field. Only valid markup is allowed, as determined by `inline` value and available controls.
- `onChange: Function` - Callback handler when the value of the field changes, passing the new value as its only argument.

Example:

```js
var el = wp.element.createElement,
	Editable = wp.blocks.Editable;

function edit( block ) {
	function onChange( value ) {
		block.setAttributes( { text: value } );
	}

	return el( Editable, {
		value: block.attributes.text,
		onChange: onChange
	} );
}
```
